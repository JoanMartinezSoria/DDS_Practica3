---
title: "Actividad Evaluable 1"
output: pdf_document
date: "2026-01-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Análisis de logs de servidor usando R (parte II)

```{r}
#install.packages("readr")
#install.packages("dplyr")
#install.packages("tidyr")
#install.packages("lubridate")
#install.packages("mltools")
#install.packages("data.table")
#install.packages("ggplot2")
#install.packages("stringr")

library("readr")
library("dplyr")
library("tidyr")
library("lubridate")
library("mltools")
library("data.table")
library("ggplot2")
library("stringr")
```

## Obtención y carga de los Datos:

#### Descomprimir el fichero comprimido que contiene los registros del servidor, y a partir de los datos extraídos, cargar en data frame los registros con las peticiones servidas.

```{r}
zip <- "./epa-http.zip"
unzip(zipfile = zip)
```

```{r}
columnas <- c("IP", "Timestamp", "Peticion", "CodigoRespuesta", "BytesReply")
df <- read_log("epa-http.csv", col_names = columnas) %>%
  mutate(BytesReply = replace_na(BytesReply, 0)) %>% 
  mutate(Timestamp = strptime(Timestamp, format = "%d:%H:%M:%S")) %>%
  mutate(
    Metodo = as.factor(str_split(Peticion, " ", simplify = TRUE)[,1]),
    URL = as.factor(str_split(Peticion, " ", simplify = TRUE)[,2]),
    Version_proto = as.factor(str_split(Peticion, " ", simplify = TRUE)[,3]),
  )

head(df, 10)
```

#### Incluid en el documento un apartado con la descripción de los datos analizados: fuente, tipología, descripción de la información contenida (los diferentes campos) y sus valores.

Para tener una primera vision de los datos que hemos cargado y con los que vamos a trabajar, podemos usar la funcion *glimpse()*.

```{r}
glimpse(df)
```

Esta nos muestra la siguiente información de nuestro *dataframe*.

-   En total nuestro dataframe cuenta con 47,748 columnas.
-   Contamos con 5 columans distintas con el siguiente contenido y tipo de dato:
    -   IP (character –\> String)
    -   Timestamp (dttm –\> POSIXlt –\> Date)
    -   Peticion (character –\> String)
    -   CodigoRespuesta (double)
    -   BytesReply (double)

## Clústering de datos
#### Utilizando un algoritmo de aprendizaje no supervisado, realizad un análisis de clústering con k-means para los datos del servidor. 

```{r}
df <- df %>% 
  mutate(Sum_char_peticion = nchar(Peticion), Sum_char_ip = nchar(IP)) %>%
  mutate(Timestamp = as.POSIXct(Timestamp))

df$URL <- NULL

epa_http_one_hot <- one_hot(as.data.table(df), sparsifyNAs = TRUE)

epa_http_one_hot$IP <- NULL
epa_http_one_hot$Timestamp <- NULL
epa_http_one_hot$Peticion <- NULL
```

```{r}
#num_cluster <- 2
#result <- kmeans(epa_http_one_hot, centers = num_cluster, nstart = 25)
#result_no_na <- kmeans(na.omit(epa_http_one_hot), centers = num_cluster)

num_cluster <- 3
result <- kmeans(epa_http_one_hot, centers = num_cluster, nstart = 25)
result_no_na <- kmeans(na.omit(epa_http_one_hot), centers = num_cluster)

#num_cluster <- 4
#result <- kmeans(epa_http_one_hot, centers = num_cluster, nstart = 25)
#result_no_na <- kmeans(na.omit(epa_http_one_hot), centers = num_cluster)
```

```{r}
Colors = as.factor(result$cluster)

ggplot(epa_http_one_hot, aes(x = BytesReply, y = Sum_char_ip, color = Colors)) +
  geom_point(alpha = 0.5) +   
  theme_minimal() +
  labs(
    title = paste("Resultado K-Means con k =", num_cluster),
    x = "Bytes Servidos",
    y = "Longitud de la IP",
    color = "Cluster"
  )
```

